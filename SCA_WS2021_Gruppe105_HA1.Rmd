---
title: "SCA_WS2021_Gruppe105_HA1"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

1) Alle 4 Dateien wurden importiert und wurden als Variablen mit passenden Namen gespeichert. Eine Zusammenfassung von jeder Variable wird ausgegeben.
```{r}
cost = read.csv2("output_cost_8Players_v0010.csv")
prices = read.csv2("output_prices_8Players_v0010.csv")
services = read.csv2("output_services_8Players_v0010.csv")
transactions = read.csv2("output_transactions_8Players_v0010.csv")

# Zusammenfassung einer Variable anzeigen
summary(cost)
```
```{r}
summary(prices)
```

```{r}
summary(services)
```

```{r}
summary(transactions)
```

2) Extrahieren Sie aus den Transaktionsdaten eine Tabelle aller existierenden Supermaerkte, in der jeder Supermarkt nur einmal enthalten ist.
```{r}
df = data.frame(unique(transactions$storename, incomparables = FALSE, fromLast = FALSE))
colnames(df) = "Store Name"
df
```

3) Extrahieren Sie aus den Transaktionsdaten eine Tabelle aller existierenden Produkte, in der jedes Produkt nur einmal enthalten ist.
```{r}
df = data.frame(unique(subset(transactions, Product != "Lost Sales")$Product))
colnames(df) = "Products"
df
```


4) Extrahieren Sie aus den Servicedaten eine Tabelle aller 20 Logistikdienstleister mitsamt deren Dienstleistungen. Jeder Logistikdienstleister soll in der Liste nur einmal enthalten sein. Sortieren Sie die Tabelle nach Shipping‐DL und Warehousing‐DL. 
```{r}
df = unique(services[c("vendor","service")])
df = df[order(df$service, df$vendor),] 
df
```


5) Berechnen Sie fuer Ihre Produkte/Gruppe die verkauften Mengen (Sales) je Region. Nutzen Sie eine einzige verkettete Anweisung fuer diese Aufgabe. 
```{r}
df = data.frame(aggregate(Sales ~ region, data = subset(transactions, Product == "Gruppe105"), sum))
head(df)
```

6) Berechnen Sie fuer jede Region den Anteil Ihres Produkts an der tatsaechlich verkauften Menge (in %).
```{r}
df = aggregate(Sales ~ region, data = subset(transactions, Product=="Gruppe105"), sum)
df$SalesInPercent =  round(df$Sales / (aggregate(Sales ~ region, data=transactions, sum))$Sales * 100, 2)
colnames(df) = c("Region", "Sales", "Sales in %")
df
```
```{r}
cat("Um den Anteil unserer Produkte der Gruppe105 zu berechnen, haben wir alle Sales nach den jeweiligen Regionen aggregiert und sie nach Gruppe105 gefiltert. Anschließend haben wir unseren prozentualen Anteil der verkauften Menge berechnet.")
```


7) Berechnen Sie die durchschnittliche Nachfrage an verkauften Produkten pro Tag nach *Ihren Produkten/Gruppe* je Region. 
Schaetzen Sie anschliessend die Monatsnachfrage mit einer Rechnung. Geben Sie alles in einer Tabelle aus. Bewertungsrelevant: Output.
```{r}
df = aggregate(cbind(Sales, Day) ~ region, data = subset(transactions, Product == "Gruppe105"), sum)
df$AvgSalesPerDay = round(df$Sales / df$Day, 2)

# Für die Schätzung der Monatsnachfrage rechnen wir mit 21 Arbeitstage im Monat (laut www.arbeitsreche.de), die wir mit AvgSalesPerDay multiplizieren.
df$MonthlyDemand = df$AvgSalesPerDay * 21
colnames(df) = c("Region", "Sales", "Day", "Average Sales per Day", "Estimated Average Sales per Month")
df
```
```{r}
cat("Um die durchschnittliche Nachfrage an verkauften Produkten für Gruppe105 pro Tag zu berechnen, haben wir die Summe der Sales und die Summe der Arbeitstage nach Regionen aggregiert, um anschließend die jeweiligen Summen miteinander zu divieren. In der vierten Spalte ergibt sich die Anzahl durchschnittlicher Nachfrage. Diese Zahlen haben wir mit 21 Arbeitstage multipliziert, um eine Abschaetzung der Monatsnachfrage aufzuzeigen.")
```


8) Geben Sie den Logistikdienstleister aus, fuer den Ihre Gruppe im Jahr 2018 die niedrigsten Kosten zu verzeichnen hat.
```{r}
MinCost = data.frame(aggregate(cost ~ vendor, data = subset(services, services$Product == "Gruppe105" & services$Year == 2018), sum))
MinCost <- MinCost[order(MinCost$cost, decreasing = FALSE),]
head(MinCost, 1)

```


9) Berechnen Sie fuer die vergangenen 5 Jahre den Profit je Jahr. Bewertungsrelevant: Output.
```{r}
df = data.frame(aggregate(Sales ~ Year, data = subset(transactions, transactions$Product == "Gruppe105"), sum))
head(df, 5)
```

10) Berechnen Sie den Profit des letzten halben Jahres im Datensatz (07/2020 ‐ 12/2020) je Monat. 
Erzeugen Sie hierfuer ein DataFrame profit, welche den Profit je Monat als Variablen speichert. 
Berechnen Sie ausserdem die Veraenderung des Profits (in %) von Monat zu Monat ueber die letzten 6 Monate als zusaetzliche Spalte fuer das DataFrame profit. Dabei sollte die Veraenderung fuer die erste Zeile 0 sein. 
Geben Sie das DataFrame aus. Bewertungsrelevant: Code, Output.
```{r}
profit = data.frame(aggregate(Sales ~ Month, 
                              data = subset(transactions, transactions$Month >= 7 &
                                                          transactions$Month <= 12 &
                                                          transactions$Year == 2020 &
                                                          transactions$Product == "Gruppe105"), sum))
# Erklärung zu Column3: 
# Dritte Spalte, erste Zeile ist 0. 
# Die Funktion tail(Sales,-1) zeigt auf die zweite Sales-Zeile. 
# Die Funktion head(Sales,-1) zeigt auf die erste Sales-Zeile.
# Diese beiden Zeilen werden miteinander dividiert und mit round() auf die zweite Nachkommastelle gerundet.

profit = cbind(profit, with(profit, {
              data.frame( #Columnx = Sales/Sales[1],
                           Column3 = c(0, (round(1-(tail(Sales,-1)/head(Sales,-1)), 2) *100)
                                     )
                        )     
}))
colnames(profit) = c("Month", "Sales", "Profit in %")
profit
```


11) Berechnen Sie, wie viel fuer Ihre Produkte/Gruppe ueber den gesamten Zeitraum fuer Transportdienstleistungen ausgegeben wurde. Berechnen Sie dazu 2 Kennzahlen (einzeln zu berechnen): 
(1) Wie viel wurde fuer verspaetete Transportdienstleistungen ausgegeben und 
(2) wie viel wurde fuer puenktliche Transportdienstleistungen ausgegeben. Bewertungsrelevant: Output.
```{r}
# Hier wird DaysScheduled mit 0 aussortiert, da kein Zeitraum zu ermitteln ist.
df1 = data.frame(aggregate(cost ~ vendor, data = subset(services, Product == "Gruppe105" &
                                                                  DaysScheduled != 0 &
                                                                  DaysExecuted > DaysScheduled), sum))
colnames(df1) = c("vendor", "cost of late service")
df1


df2 = data.frame(aggregate(cost ~ vendor, data = subset(services, Product == "Gruppe105" &
                                                                  DaysScheduled != 0 &
                                                                  DaysScheduled <= DaysExecuted), sum))
colnames(df2) = c("vendor", "cost of timely service")
df2

```


12) Berechnen Sie, wie viel Sie die reale Ausfuehrung einer *Lagerdienstleistung* tatsaechlich kostet. D.h. rechnen Sie die Gesamtkosten, die Ihr Produkt/Gruppe fuer Qscheduled erzeugt hat, auf die tatsaechliche Lagerleistung (QExecuted) um. 
(1) Geben Sie die Kosten pro Stueck an. 
(2) Berechnen Sie anschliessend, wie viel Prozent Sie mehr bezahlt haben (bei einem Vergleich von Kosten QExecuted pro Steuck zu Kosten QScheduled pro Stueck). Bewertungsrelevant: Output.
```{r}
df1 = aggregate(cbind(QScheduled, QExecuted, cost) ~ Product, data = subset(services, Product == "Gruppe105" & 
                                                                                      service == "Warehousing"), sum)
# Hier werden die Kosten pro geplantes Stueck berechnet
df1$ScheduledItem = round(df1$cost/df1$QScheduled, 2) 

# Hier werden die Kosten pro tatsaechlich abgefertigtes Stueck berechnet
df1$ExecutedItem = round(df1$cost/df1$QExecuted, 2) 

# Hier wird die Differenz der Kosten von ExecutedItem und ScheduledItem in Prozent berechnet
df1$Differ = round(df1$ExecutedItem - df1$ScheduledItem, 2)*100

colnames(df1) = c("Product", "Scheduled in total", "Executed in total", "Cost", 
                  "Scheduled Item", "Executed Item", "Difference in %")
head(df1)
```
```{r}
cat("Die reale Ausfuehrung der Warehousing bzw. Lagerdienstleistung kostete insgesamt", df1[1,3],"€, wobei",df1[1,2],"€ geplant waren. Zudem werden Kosten pro Stück von", df1[1,5], "€ geplant. Jedoch betrugen die tatsaechlichen Kosten pro Stück", df1[1,6], "€. Demzufolge ergibt sich eine prozentuale Differenz von", df1[1,7], "%, die wir mehr bezahlt haben.")
```



```{r}
library(ggplot2) #Library Import
daten = aggregate(Sales~Product, data=transactions, sum)

ggplot(data=daten, aes(x=Product, y=Sales, fill=Product))

```


13) Waehlen Sie eine geeignete Kennzahl zur Bewertung Ihrer Shipping‐Dienstleister. Beachten Sie dabei, was die Qualiteat der Shipping‐Dienstleister ausmacht. Begruenden Sie die Wahl der Kennzahl kurz. Berechnen Sie diese Kennzahl zunaechst fuer alle Dienstleistungen als zusaetzliche Variable der Services Tabelle, d.h. fuer jede einzelne Dienstleistung.Berechnen Sie anschliessend die durchschnittliche Kennzahl der Shipping‐Dienstleister fuer die Dienstleistungen an Ihrem Produkt ueber die gesamte Laufzeit (5 Jahre).Geben Sie Ihre Ergebnisse in einer Tabelle aus, in der die Kennzahl‐Werte aufsteigend sortiert sind. Bewertungsrelevant: Begruendung, Code, Output.
```{r}
#Berechnen Sie OTD für alle Dienstleistungen als zusaetzliche Variable der Services Tabelle.
services$OTD = services$DaysScheduled >= services$DaysExecuted

#ODBDD = Orders Delivered on or Before Due Date
shipping_105_vendors_ODBDD <- subset(services, service == "Shipping" & Product == "Gruppe105") %>% 
  aggregate(OTD ~ vendor, data = ., sum) %>%
  setNames(., c("Vendor", "ODBDD"))

#Anzahl an Bestellungen pro Lieferant.
shipping_105_vendors_total_orders <- subset(services, service == "Shipping" & Product == "Gruppe105") %>% 
  aggregate(OTD ~ vendor, data = ., length) %>%
  setNames(., c("Vendor", "total_orders"))

#Beide Dataframes mergen und OTD berechnen.
shipping_105_vendors <- merge(x = shipping_105_vendors_ODBDD, y = shipping_105_vendors_total_orders, by = "Vendor", all = TRUE)
shipping_105_vendors$OTB <- shipping_105_vendors$ODBDD / shipping_105_vendors$total_orders

#Zu Prozent umrechnen
shipping_105_vendors$OTB <- (shipping_105_vendors$OTB * 100) %>% round(., 2)

#Ausgabe, Kennzahl‐Werte aufsteigend sortiert.
shipping_105_vendors <- subset(shipping_105_vendors, select = -c(ODBDD,total_orders))
shipping_105_vendors[order(-shipping_105_vendors$OTB),]

#Clean up
rm(shipping_105_vendors_ODBDD, shipping_105_vendors_total_orders, shipping_105_vendors)

```

```{r}
cat("Begruendung zu Aufgabe 13: 
Da bekannt ist, dass die Shipping-Dienstleister die vereinbarte Lieferzeit häufig ueberschreiten, verwenden wir On-Time Delivery Rate (OTD-Rate) als Kennzahl zur Bewertung.
Diese Berechnung erfolgt mit der folgenden Berechnung:
OTD-Rate = count(DaysScheduled >= DaysExecuted) / count(Orders)")
```

14) Waehlen Sie eine geeignete Kennzahl zur Bewertung Ihrer Warehousing‐Dienstleister. Beachten Sie dabei,was die Qualiteat der Warehousing‐Dienstleister ausmacht. Begruenden Sie die Wahl der Kennzahl kurz. Berechnen Sie diese Kennzahl zunaechst fuer alle Dienstleistungen als zusaetzliche Variable der Services‐Tabelle, d.h. fuer jede einzelne Dienstleistung. Berechnen Sie anschliessend die durchschnittliche Kennzahl fuer die Warehousing‐Dienstleister fuer die Dienstleistungen an Ihrem Produkt ueber die gesamte Laufzeit (5 Jahre). Geben Sie Ihre Ergebnisse in einer Tabelle aus, in der die Kennzahl‐Werte aufsteigend sortiert sind. Bewertungsrelevant: Begruendung, Code, Output.
```{r}
#TODO Was ist wenn die Lieferung zu groß war?

#Berechnen Sie diese Kennzahl zunaechst fuer alle Dienstleistungen als zusaetzliche Variable der Services‐Tabelle.
services$IFR = services$QExecuted / services$QScheduled

#IFR aggregiert für jeden Warehousing-DL berechnen.
warehousing_105_vendors <- subset(services, service == "Warehousing" & Product == "Gruppe105") %>%
  aggregate(IFR ~ vendor, data = ., mean)

#Zu Prozent umrechnen.
warehousing_105_vendors$IFR <- (warehousing_105_vendors$IFR * 100) %>% round(., 2)

#Sortieren und ausgeben.
warehousing_105_vendors[order(-warehousing_105_vendors$IFR),]

#TODO cat("CAPS Warehousing hat die beste Order Fill Rate mit 85,65%")

#Clean up
rm(warehousing_105_vendors)
```

```{r}
cat("Begruendung zu Aufgabe 14: Schlechte Warehousing-Dienstleister führen dazu das die Waren frueher als erwartet nicht verfügbar sind. Aus der Aufgabenbeschreibung geht hervor das die Warehousing-DL häufig falsche Mengenliefern, was aber erst im nachhinein auffällt. Unsere gewählte Kennzahl ist die Item Fill Rate (IFR). Sie untersucht wie genau eine Lieferung war gemessen an der bestellten Menge.
Item Fill Rate (IFR) = Number of Items delivered to customers / Numer of Items ordered by customer")
```

15) Visualisieren Sie in geeigneter Form den Marktanteil (tatsaechliche verkaufte Menge) aller Produkte im Markt in einem ggplot. Es bietet sich an, einen aggregierten Datensatz zu nutzen. Bewertungsrelevant: Begruendung, Code, Output.
```{r}
#Entferne Lost Sales, berechne Marktanteil in Prozent und Runde auf zwei Nachkommastellen.
marktanteil_tortendiagramm <- transactions[!(transactions$Product=="Lost Sales"),] %>% 
  aggregate(Sales ~ Product, data = ., sum) %>%
  mutate(Percent = Sales/sum(Sales)*100)
marktanteil_tortendiagramm$Percent = round(marktanteil_tortendiagramm$Percent, 2)

#Berechne Prozente in Flächeninhalt des Kreises um. Wird gespeichert in lab.ypos
marktanteil_tortendiagramm <- marktanteil_tortendiagramm %>%
  mutate(lab.ypos = cumsum(Percent) - 0.5*Percent)

#Unterschiedliche Farben für jeden Marktteilnehmer.
mycols <- c("#0073C2FF", "#EFC000FF", "#868686FF", "#CD534CFF", "#9173CcFF", "#7FC000FF", "#861686FF", "#CD134CFF")

#Tortendiagramm zeichnen lassen.
ggplot(marktanteil_tortendiagramm, aes(x = "", y = Percent, fill = Product)) +
  geom_bar(width = 1, stat = "identity", color = "white") +
  coord_polar("y", start = 0) +
  geom_text(aes(y = lab.ypos, label = Percent), color = "white") +
  scale_fill_manual(values = mycols) +
  theme_void()

#Clean up
rm(mycols, marktanteil_tortendiagramm)

```

```{r}
cat("Begruendung zu Aufgabe 15: Wir haben uns für ein Tortendiagramm entschieden, da es den Marktanteil am übersichtlichsten und verständlichsten darstellt. Zusätzlich wurde der Marktanteil in Prozent umgerechnet, um die genauen Unterschiede im Nachkommerbereich einfacher zu erfassen.")
```


16) Visualisieren Sie in geeigneter Form die gewaehlte Qualitaetskennzahl der Warehouse‐Dienstleister in einem ggplot. Durch die Visualisierung soll eine Vergleichbarkeit der Dienstleister moeglich sein. Unterstuetzen die abgebildeten Daten die Entscheidung fuer einen WH‐DL? Kommentieren Sie. Bewertungsrelevant: Begruendung, Code, Output, Kommentar.
```{r}
#Boxplot zeichnen lassen für WH-DL und Gruppe105. Unsere gewählt Kennzahl ist IFR.
subset(services, service=="Warehousing" & Product=="Gruppe105") %>%
  ggplot(., aes(x = vendor, y = IFR)) + 
  geom_boxplot() +
  theme(axis.text.x = element_text(angle=45,hjust=1,vjust=1)) 

cat("Begruendung zu Aufgabe 16: Wir entscheiden uns für einen Boxplot. Dieser gibt uns ein genauers Bild über den Median, Ausreißer und die Standardabweichung. Bevorzugt sollte der WH-DL sein der eine möglichst geringe Standardabschweihung hat und gleichzeigit am nächsten bei IFR=1 liegt. ")

cat("Kommentar: Beim Ablesen des Boxplots fällt auf wie klein die Unterschiede zwischen den WH-DL sind. VWL Warehousing hat den an IFR=1 nächsten Median, jedoch hat OPS Warehousing eine geringere Standartabweichung und liegt fast gleich auf. Eine eindeutige Entscheidung kann nicht getroffen werden.")
```


17) Visualisieren Sie in geeigneter Form die gewaehlte Qualitaetskennzahl der Warehouse‐Dienstleister im Vergleich ueber die verschiedenen Regionen in einem ggplot. Wie bewerten Sie die Qualitaet der WH‐DL insgesamt? Kommentieren Sie. Bewertungsrelevant: Begruendung, Code, Output, Kommentar.
```{r}
subset(services, service=="Warehousing") %>% ggplot(., 
       aes(x = vendor, y = region, fill = IFR)) + 
  geom_raster() +
  scale_fill_gradient(low = "red", high="green") + 
  theme(axis.text.x = element_text(angle=45,hjust=1,vjust=1)) 
cat("Kommentar: Es fällt auf das DWL Warehousing besonders schlecht in Japan liefert, dort sollte man auf IntEx Warehousing umgesteigen. Generel lässt die Heat-Map leicht ablesen welcher WH-DL in welcher Region gut/schlecht Liefern, gemessen an IFR.")
```

```{r}
cat("Begruendung zu Aufgabe 17: Wir entscheiden uns für eine Heat-Map, wobei Grün besser und rot schlechter darstellt. Da es bei unseren Daten keine zu großen Lieferungen gab, eigent sich dieses Verfahren. Falls es zu große Lieferungen gegeben hätte, müssten die Daten vorher aufbereitet werden.")
```

18) Visualisieren Sie in geeigneter Form die Qualitaetskennzahl der Shipping‐Dienstleister je Monat fuer das Jahr
2017 in einem ggplot (ueber alle Regionen zusammen) Wie bewerten Sie die Qualitaet der Shipping‐DL insgesamt?
Kommentieren Sie. Bewertungsrelevant: Begruendung, Code, Output, Kommentar.

Begruendung: Wir entscheiden uns für ein Liniendiagramm, um die Entwicklung über die Monate darzustellen. Es stellt einfach dar welcher SH-DL in welchem Monat am bessten war. Jeder DL bekommt eine eigene Linie die sich durch unterschiedliche Farben unterscheiden lassen. Wir haben die OTD-Rate als Kennzahl genommen.
```{r}
subset(services, service=="Shipping" & Year=="2017") %>% aggregate(OTD~vendor + Month, data = ., mean) %>% 
  ggplot(aes(x = Month, y = OTD)) + 
  geom_line()

```


















