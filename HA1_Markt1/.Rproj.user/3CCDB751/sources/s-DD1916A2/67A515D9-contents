---
title: "Lektion 5 - Grundlagen in R"
mainfont: Calibri
output:
  pdf_document:
    latex_engine: xelatex
    number_sections: yes
    toc: yes
    toc_depth: 4
  html_document:
    number_sections: yes
    toc: yes
    toc_depth: 4
  html_notebook:
    number_sections: yes
    toc: yes
    toc_depth: 4
---


# Vorbemerkung

**Hinweis 1:**  
Die grauen Bereiche sind "R Code Chuncks". Sie enthalten Quelltext und koennen in R-Studio ausgefuehrt werden. Sie enthalten meist die Funktion von Interesse sowie eine oder mehrere weitere Funktionen, die Ergebnisse dieser Funktion anzeigen ("*ausgeben*").   

**Hinweis 2:**  
Die Gliederungsebenen fangen zur Orientierung jeweils mit Akronymen fuer den Inhalt. (z.B. Ba1 fuer Basics 1, Ba2 fuer Basics 2, P fuer Problem, Vis fuer Visualisierung)   

<!--##############################################-->
# Ba1: Grundlagen des data handling in R (Basics 1)
<!--##############################################-->

Bevor Daten geladen werden koennen, muss das Working directory (Arbeitsverzeichnis) ausgewaehlt werden. In R-Studio:  

* Menu -> Session -> Set Working Directory -> Choose Directory... -> Ordner auswaehlen, in dem die Datei liegt
* Strg + Umschalt + H

## Ba1: Laden der Daten
Laden als csv2, d.h. europaeisches csv Format mit ',' statt '.' als Dezimalzeichen und ';' statt ',' als Datentrennung. Die Daten werden in die Variable 'electronics' geladen. Durch diesen Befehl werden die Daten in ein Data Frame (DF) geladen.
Der Befehl ist ein Beispiel fuer die Definition einer Variable bzw. der **Zuweisung** von Werten zu einer Variable:  

* *Left hand side (LHS) = Right hand side (RHS)*  

Die LHS bekommt einen Inhalt zugewiesen, d.h. wird erstellt oder veraendert, die RHS stellt den Inhalt dar, der  zugewiesen wird. Dabei kann es sich bei der RHS auch um komplexe Berechnungen oder Befehle handeln, deren Ergebnisse der LHS zugewiesen werden. Findet keine Zuweisung statt (gibt es kein **=** ), dann wird das Ergebnis in der Console angezeigt ("ausgegeben").
```{r }
# Laden der Daten
electronics = read.csv2("05_Problem_Set_5.csv")
```

Die existierenden Variablen im Environment koennen mit dem folgenden Befehl angezeigt werden oder in der Environment-Section in RStudio eingesehen werden.
```{r }
# Environment zusammenfassen und anzeigen
ls()
```

## Ba1: Struktur und Zusammenfassung des data frame erkunden
### Ba1: (1) Struktur der Daten anzeigen
Die Struktur eines DF untersuchen, d.h. welche Vektoren/Spalten sind im DF enthalten, welchen Datentyp haben diese sowie eine Auswahl der Werte.
```{r }
# Struktur einer Variable anzeigen
str(electronics)
```

### Ba1: (2) Zusammenfassung der Daten anzeigen
Die Zusammenfassung enthaelt Min, 1st Quartil, Median, Mean, 3rd Quartil, Max.  
**Hinweis:** Die Tabelle zeigt zusammenfassende Statistik zu den Unter-Variablen der Variable (den Spalten des Daten-Objektes).
```{r }
# Zusammenfassung einer Variable anzeigen
summary(electronics)
```

### Ba1: (3) Mittelwert eines Vektors
Hier: Mittelwert des Umsatzes je Bestellung
```{r }
# Mittelwert ausgeben
mean(electronics$PriceTotal)

#Zum Zwecke von Uebersicht und Struktur: cat()-Funktion nutzen
cat("Der durchschnittliche Umsatz je Bestellung betraegt", mean(electronics$PriceTotal),"$","\n")

#Dazu kann man noch sinnvoll runden:
cat("Der durchschnittliche Umsatz je Bestellung betraegt", round(mean(electronics$PriceTotal), 2),"$")
```

## Ba1: Daten untersuchen
### Ba1: (1) Daten zu einer Tabelle aggregieren (Anzahl unterschiedlicher Werte wiedergeben)
Hier: Aggregation der Standorte
```{r }
# Auspraegungen einer Variable mit Anzahl der Auspraegungen tabellarisieren ("aggregieren")
table(electronics$Location)

#Zum Zwecke von Uebersicht und Struktur: Umwandlung in Dataframe
locations = data.frame(table(electronics$Location))
colnames(locations) = c("Location","Order count")
locations
```

### Ba1: (2) Daten in Abhaengigkeit einer weiteren Variable entsprechend einer Funktion aggregieren
Neben der einfachen Tabellarisierung der Anzahl der verschiedenen Auspraegungen koennen auch Funktionen auf die Auspraegungen angewandt werden.
Hier: zu aggregierende Variable: Umsatz; In Abhaengigkeit von: Service Level (24 Stunden, 36 Stunden, 48 Stunden Lieferzeitversprechen); Funktion Summe 
```{r }
# Auspraegungen mit Funktionen tabellarisieren ("aggregieren")
tapply(electronics$PriceTotal, electronics$ServiceLevel, sum)
```

### Ba1: (3) Sortieren von Daten (bzw. Output von Befehlen)
Hier: Sortieren von aggregiertem Umsatz in Abhaengigkeit des Standortes nach der Funktion Summe

**Hinweis:** sort() sortiert ohne weitere "Argumente" (Eingabemoeglichkeiten fuer die Funktion, die deren Arbeitsweise veraendert / anpasst) aufsteigend  
**Hinweis2:** die verbindung von sort() und tapply(), head() und sort(), oder tail(), sort() und tapply() wird als **Verschachtelung** bezeichnet.
```{r}
#Umsatz je Service Level (sortiert)
sort(tapply(electronics$PriceTotal, electronics$Location, sum))

cat("\n \n") # Leerzeile fuer Anschaulichkeit, bitte ignorieren


#Umsatz je Service Level (sortiert), nur die ersten 4
sort(tapply(electronics$PriceTotal, electronics$Location, sum))[1:4]

cat("\n \n") # Leerzeile fuer Anschaulichkeit, bitte ignorieren


#Umsatz je Service Level (sortiert), nummer 3 bis 6
sort(tapply(electronics$PriceTotal, electronics$Location, sum))[3:6]

cat("\n \n") # Leerzeile fuer Anschaulichkeit, bitte ignorieren


#Umsatz je Service Level (sortiert), Tabellenkopf (obersten 6)
head(sort(tapply(electronics$PriceTotal, electronics$Location, sum)))

cat("\n \n") # Leerzeile fuer Anschaulichkeit, bitte ignorieren


#Umsatz je Service Level (sortiert), Tabellenende (untersten 6)
tail(sort(tapply(electronics$PriceTotal, electronics$Location, sum)))
```


<!--##############################################-->
# P5-1: Problem 5-1
<!--##############################################-->

## P5-1: Problem 5-1A
Sortieren Sie die OrderNo nach produziertem Umsatz und zeigen Sie nur den Tabellenkopf!  
```{r echo=FALSE}
# Antwort (bitte "NULL" ersetzen und vollstaendige verschachtelte Funktion formulieren):
head(sort(tapply(electronics$PriceTotal, electronics$OrderNo, sum)))
```

## P5-1: Problem 5-1B
Sortieren Sie die Kunden nach dem durchschnittlichem Umsatz je Bestellung. Zeigen Sie 20 an!  
```{r, echo=FALSE}
# Antwort (bitte "NULL" ersetzen und vollstaendige verschachtelte Funktion formulieren):
sort(tapply(electronics$PriceTotal, electronics$CustomerName, mean))[1:20]
```

## P5-1: Problem 5-1C
Wer sind die Top 10 Kunden nach durchschnittlichem Umsatz, absteigend sortiert?  

**Hinweis:** Nutzen Sie die Hilfe, um herauszufinden, durch welches **Argument** der Output von sort() absteigend sortiert wird.  
```{r, echo=FALSE}
# Antwort (bitte "NULL" ersetzen und vollstaendige verschachtelte Funktion formulieren):
sort(tapply(electronics$PriceTotal, electronics$CustomerName, mean), decreasing = TRUE)[1:10]
```


<!--##############################################-->
# Ba2: Auswaehlen und hinzufuegen (Basics 2)
<!--##############################################-->

## Ba2: (1) Spalte hinzufuegen
Eine Spalte kann aehnlich der Definition einer Variablen hinzugefuegt werden. D.h. auf der LHS wird eine Variable definiert in der Form `DF$NeueSpalte`  

Hier: Hinzufuegen der Spalte OCT (fuer "order cycle time"), welche Warehouse time und transit time addiert.
```{r }
# Spalte einer Variable anlegen
electronics$OCT = electronics$TimeWarehouse + electronics$TimeTransit

# Anzeigen einer Auswahl: Zeile 1 bis 10, Spalten LSP und OCT
electronics[1:10 , c("LSP", "OCT")]
```

## Ba2: (2) Daten auswaehlen mit Kondition: logische Einschraenkung
Nachfolgend wird eine Auswahl (ein **subset**) aus einer Datenmenge entnommen, mit der `select` Expression ("[,]"). Dabei werden Konditionen fuer die Auswahl definiert.  

Hier: Daten auswaehlen, welche die Kondition *Unternehmen aus Frankreich* erfuellen.  

Eingeschraenkt werden koennen  
* Zeilen (vor dem ",") sowie 
* Spalten (nach dem ","). 

Hier werden nur die *Zeilen** ausgewaehlt, die in der Location-Spalte "France" stehen haben. Ausserdem werden nur die Spalten Customer, CustomerName und Location ausgewaehlt.
```{r}
# Auszug aus Daten / Auswahl an Daten / eingeschraenkten Datensatz einer neuen Variable uebergeben
FrenchOrders = electronics[electronics$Location == "France", c("Customer", "CustomerName", "Location")]

# Daten anzeigen
head(FrenchOrders)
```


## Ba2: (3) Daten auswaehlen mit Kondition: subset Funktion
Nachfolgend wird eine Auswahl (ein *subset*) aus einer Datenmenge entnommen, mit der `subset` Funktion. Dabei werden Konditionen fuer die Auswahl definiert.  

Hier: Daten auswaehlen, welche die Kondition *Unternehmen aus Frankreich* erfuellen. Es findet **keine** Einschraenkung der Spalten statt.
```{r}
# Auszug aus Daten / Auswahl an Daten / eingeschraenkten Datensatz einer neuen Variable uebergeben
FrenchOrders = subset(electronics, Location == "France")

# Daten anzeigen
head(FrenchOrders)
```

## Ba2: (4) Daten auswaehlen mit mehreren Konditionen
Die Auswahl kann weiter praezisiert werden durch logische Konditionen:

* Logische "UND" Verbindung durch: &
* Logische "ODER" Verbindung durch: |

Hier: Daten auswaehlen, welche die Kondition *Leistung in Frankreich erbracht* und *innerhalb von ServiceLevel 24h* erfuellen  

**Hinweis:** Achten Sie auf den Vergleichsoperator mit doppeltem istgleich "=="
```{r}
# mit select expression
head(electronics[electronics$Location == "France" & electronics$ServiceLevel == 24 ,])

# mit subset Funktion
head(subset(electronics, Location == "France" & ServiceLevel == 24))
```


<!--##############################################-->
# P5-2: Problem 5-2
<!--##############################################-->

## P5-2: Problem 5-2A
Erstellen Sie fuer das Data Frame *electronics* eine Spalte 'IFR', welche die Item Fill Rate enthaelt:  
$$IFR = \frac{\#\ of\ items\ delivered}{\#\ of\ items\ ordered\ by\ the\ customer};\ IFR \ Rate=\frac{\sum\ IFR}{\#\ of \ customer \ orders}$$ 
```{r, echo=FALSE}
#(1) Item Fill Rate (IFR) pro Bestellung (d.h. Zeilen des Data Frame) berechnen und als Spalte 'IFR' dem DF 'electronics' hinzufuegen
# Antwort (NA ersetzen):
electronics$IFR = electronics$ItemsReceived / electronics$ItemsOrdered

#(2) Mittlere IFR berechnen
# Antwort (bitte "NULL" ersetzen und vollstaendige verschachtelte Funktion formulieren):
mean(electronics$IFR)
```


## P5-2: Problem 5-2B
Erstellen Sie fuer das Data Frame *electronics* einen Spalte 'OTD', welche den on-time delivery (OTD)-Status jeder Bestellung enthaelt ('TRUE' oder 1 falls puenktlich, 'FALSE' oder 0 falls unpuenktlich). Berechnen Sie anschliessend die OTD-Rate, indem Sie den Durchschnitt ueber alle Bestellungen bilden.  
$$OTD = 1 \ falls \ puenktlich, \ 0\ falls \ unpuenktlich; \ OTD \ Rate=\frac{\sum\ OTD}{\#\ of \ customer \ orders}$$ 
```{r, echo=FALSE}
#(1) OTD-Rate pro Bestellung (d.h. Zeilen des Data Frame) berechnen und als Spalte 'OTD' dem DF 'electronics' hinzufuegen. Hinweis: Es reicht aus, nach dem Gleichzeichen die Bedingung zu schreiben
# Antwort (NA ersetzen):
electronics$OTD = electronics$OCT <= electronics$ServiceLevel
#(2) Mittlere OTD berechnen
# Antwort (bitte "NULL" ersetzen und vollstaendige verschachtelte Funktion formulieren):
mean(electronics$OTD)
```


<!--##############################################-->
# P5-3: Problem 5-3
<!--##############################################-->
## P5-3: Problem 5-3A
Ermitteln Sie den aufsummierten/aggregierten Umsatz **je** Land, um die nationalen Vertriebseinheiten zu bewerten. Erzeugen Sie dabei **direkt** ein neues data frame mit dem Namen 'RevenueCou'.  

**Hinweis:** Beachten Sie zur Loesungsfindung die Vorlesungsunterlagen. Der benoetigte Befehl wurde bisher noch nicht verwendet. Nutzen Sie moeglichst auch die Suchfunktion. Suchen Sie z.B. nach "aggregiert" oder Wortteilen davon.

```{r echo=FALSE}
#(1) Neues DF 'RevenueCou' mit aufsummierten Umsatz je Land
# Antwort (NA ersetzen):
RevenueCou = aggregate(PriceTotal ~ Location, data = electronics, sum)

#(2) Zeigen Sie den Tabellenkopf des DF RevenueCou
head(RevenueCou)

```

## P5-3: Problem 5-3B
Ermitteln Sie die Item Fill Rate **je** Kunden, um erste Rueckschluesse auf die Qualitaet des Warehousing zu ziehen. Erzeugen Sie dabei **direkt** ein neues data frame mit dem Namen 'IFRCust'.
```{r echo=FALSE}
#(1) Neues DF 'IFRCust' mit mittlerer IFR je Kunden
# Antwort (NA ersetzen):
IFRCust = aggregate(IFR ~ Customer, data = electronics, mean)

#(2) Zeigen Sie den Tabellenkopf des DF IFRCust
head(IFRCust)
```

## P5-3: Problem 5-3C
Ermitteln Sie die durchschnittliche Order Transit Time **je** Logistikdienstleister je Service Level, um die Logistikdienstleister zu bewerten. Erzeugen Sie dabei **direkt** ein neues data frame mit dem Namen 'LSP'.

Hinweis: Die gewuenschte Tabelle muss schrittweise erstellt werden. Dazu wird, nacheinander:  

* (1) das DF erstellt mit dem Service Level 24h
* (2) die Spalte 'ServiceLevel' umbenannt
* (3) ein Hilfs-DF erstellt mit dem Service Level 36h
* (4) die 'ServicelLevel'-Spalte vom Hilfs-DF mit dem DF 'LSP' vereinigt
* (5) die neue Spalte 'ServiceLevel' umbenannt
* (6) Schritt (3) und (4) gleichzeitig ausgefuehrt mit Service Level 48h
* (7) die neue Spalte 'ServiceLevel' umbenannt.

**Hinweis:** Beachten Sie zur Loesungsfindung die Vorlesungsunterlagen. Der benoetigte Befehl wurde bisher noch nicht verwendet.

```{r echo=FALSE}
#(1) Neues DF 'LSP' mit mittlerer Transit time je Logistics Service Provider, nur fuer 
# Bestellungen mit Service Level == 24h
# Antwort (NA ersetzen):
LSP = aggregate(TimeTransit ~ LSP, data = subset(electronics, ServiceLevel == 24), mean)

#(2) anschliessend umbenennen, um den Ueberblick zu behalten!
names(LSP)[2] = "TimeTransit(24h)"

# Anzeigen des Tabellenkopfs vom DF 'LSP'
head(LSP)

#(3) Neues Hilfs-DF LSP2 mit mittlerer Transit time je Logistics Service Provider, nur 
# fuer Bestellungen mit Service Level == 36h
# Antwort (NA ersetzen):
LSP2 = aggregate(TimeTransit ~ LSP, data = subset(electronics, ServiceLevel == 36), mean)

#(4) Verbinden ("Verschmelzen") der Data Frames ueber das Attribut "LSP"
# Antwort (NA ersetzen):
LSP = merge(LSP, LSP2, by.x = "LSP", by.y = "LSP")

#(5) anschliessend umbenennen, um Ueberblick zu behalten! (Alternativer Aufruf der 
# umzubenennenden Spalte)
names(LSP)[names(LSP) == "TimeTransit"] = "TimeTransit(36h)"
# Anzeigen des Tabellenkopfs vom DF 'LSP'
head(LSP)

#(6) Verbinden der Schritte (3) und (4) fuer Service Level == 48h. Hier muss kein Hilfs-DF erstellt werden.
# Antwort (NA ersetzen):
LSP = merge(LSP, aggregate(TimeTransit ~ LSP, data = subset(electronics, ServiceLevel == 48), mean), by.x = "LSP", by.y = "LSP")


#(7) anschliessend umbenennen, um Ueberblick zu behalten!
names(LSP)[names(LSP) == "TimeTransit"] = "TimeTransit(48h)"

# Anzeigen des Tabellenkopfs vom DF 'LSP'
head(LSP)

```


<!--##############################################-->
# Vis: Datenvisualisierung
<!--##############################################-->


**Hinweis zur Installation von Packages: Hier wird das ggplot2 package installiert - Dies muss nur einmalig erfolgen. Bitte den nachfolgenden Befehl in die Console kopieren und ausfuehren, wenn es noch nie ausgefuehrt wurde:**  

`install.packages("ggplot2")`

## Vis: Laden von Packages
Installierte Packages muessen vor der Nutzung geladen werden. Anderfalls stehen die Funktionen nicht zur Verfuegung.
```{r }
library("ggplot2")
```

## Vis: Einfuehrung in ggplots / Visualisierung von Scatterplots
GGplot ist eines der fuehrenden Packages fuer Datenvisualisierung in R. Die Plots werden Schicht fuer Schicht erstellt (siehe nachfolgene Beispiele). Diese Funktionsweise kann nicht auf alle anderen Packages uebertragen werden.  

Hier: Beispiel eines Scatterplots

*Hinweis: nachfolgend werden die Plots nicht in Variablen gespeichert und werden daher direkt ausgegeben. Selbstverstaendlich koennen die Plots auch mit einer Zuweisung (=) in Variablen gespeichert werden.*
```{r }
# (1) Leerer Plot
ggplot()

# (2) Plot mit Daten. Durch Auswahl des Data Frame als "data =", koennen die Spalten 
# ohne zusaetzliche Nennung des DF bei der Festlegung der aesthetics genutzt werden. Die  
# Daten sind nicht erkennbar, da keine Art des Plots festgelegt wurde
ggplot(data = electronics, 
       aes(x = OrderNo, y = TimeTransit))

# (3) Plot mit Daten und Festlegung der Art des Plots
ggplot(electronics, 
       aes(x = OrderNo, y = TimeTransit)) + 
  geom_point()

# (4) Plot mit Daten, Festlegung der Art des Plots und Farben des Plots nach dritter 
# Variable
ggplot(electronics, 
       aes(x = OrderNo, y = TimeTransit, colour = ServiceLevel)) + 
  geom_point()

# (5) Plot mit Daten, Festlegung der Art des Plots und Farben des Plots nach dritter 
# Variable (die zu einer Faktor-Variable umgewandelt ("typecasted") wird)
ggplot(electronics, 
       aes(x = OrderNo, y = TimeTransit, colour = as.factor(ServiceLevel))) + 
  geom_point()

# (6) Plot entsprechend (5) mit unterschiedlichen Formen
ggplot(electronics, 
       aes(x = OrderNo, y = TimeTransit, colour = as.factor(ServiceLevel), shape = as.factor(ServiceLevel))) + 
  geom_point()

# (7) Plot entsprechend (6) mit manuell festgelegten Farben
ggplot(electronics, 
       aes(x = OrderNo, y = TimeTransit, colour = as.factor(ServiceLevel), shape = as.factor(ServiceLevel))) +
  geom_point() + 
  scale_colour_manual(values = c("red", "blue", "purple"))
  
  # (8) Plot entsprechend (7) mit manuell festgelegten Achsenbeschriftungen
ggplot(electronics, 
       aes(x = OrderNo, y = TimeTransit, colour = as.factor(ServiceLevel), shape = as.factor(ServiceLevel))) +
  geom_point() + 
  scale_colour_manual(values = c("red", "blue", "purple")) + scale_x_continuous(breaks = c(4329000, 4330000, 4331000, 4332000), labels = c("2014", "2015", "2016", "2017")) + xlab("Year")
```

## Vis: Visualisierung von Boxplots
Beachte, dass ein einfacher Boxplot nur eine Variable hat, deren Werte auf der Y-Achse abgebildet werden. Jedoch erwartet ggplot eine Uebergabe fuer die X-Achse. Dies wird hier durch "" umgangen.  

Hier: (1) Boxplot der bestellten Items ((2) nach Land aufgeteilt)
```{r}
# (1) Boxplot der bestellten Items (eindimensional / "einfach")
ggplot(electronics, 
       aes(x = "", y = ItemsOrdered)) + geom_boxplot()


# (2) Boxplot der bestellten Items nach Land
ggplot(electronics, 
       aes(x = Location, y = ItemsOrdered)) + geom_boxplot()
```

## Vis: Visualisierung von Histograms
Neben der Visualisierungsform wird nachfolgend auch aufgezeigt, dass der Art des Plots selbst aesthetics hinzugefuegt werden koennen. 

Hier: Histogramm der Umsaetze der Bestellungen
```{r}
# (1) Histogramm der Umsaetze je Order
ggplot(electronics, 
       aes(x = PriceTotal)) + 
  geom_histogram()

# (2) Plot entsprechend (1) mit Fuellfarbe und Raendern
ggplot(electronics, 
       aes(x = PriceTotal)) + 
  geom_histogram(fill = "dodgerblue", colour = "firebrick")

# (3) Plot entsprechend (2) mit angepasster Bins ueber Bin-Groesse
ggplot(electronics, 
       aes(x = PriceTotal)) + 
  geom_histogram(binwidth = 500, fill = "dodgerblue", colour = "firebrick")

# (4) Plot entsprechend (2) mit angepasster Bins ueber Anzahl Bin
ggplot(electronics, 
       aes(x = PriceTotal)) + 
  geom_histogram(bins = 150, fill = "dodgerblue", colour = "firebrick")
```

## Vis: Visualisierung von Heat Maps
Hier: Transitzeit nach OrderNo

```{r}
# (1) Heat Map der Transitzeit nach OrderNo
ggplot(electronics, 
       aes(x = OrderNo, y = "", fill = TimeTransit)) + 
  geom_raster()

# (2) Plot entsprechend (1) mit manueller Farbwahl
ggplot(electronics, 
       aes(x = OrderNo, y = "", fill = TimeTransit)) + 
  geom_raster() +
  scale_fill_gradient(low = "green", high = "red")
```

Hier: Heat Map der Transitzeit ueber LSP und Location 
```{r}
# (1) Heat Map der Transitzeit ueber LSP und Location 
ggplot(electronics, 
       aes(x = LSP, y = Location, fill = TimeTransit)) + 
  geom_raster()

# (2) Plot entsprechend (1) mit manueller Farbwahl
ggplot(electronics, 
       aes(x = LSP, y = Location, fill = TimeTransit)) + 
  geom_raster() +
  scale_fill_gradient(low = "green", high="red")

# Achtung! Diese Darstellung zeigt nicht die durchschnittliche Transit Time an. Zu diesem Zweck muesste zunaechst ein aggregiertes DF erzeugt werden. Die beiden Darstellungen "stapeln" quasi alle Beobachtungen uebereinander und zeigen somit immer nur die letzte Beobachtung aus der jeweiligen Kategorie an.
```


<!--##############################################-->
# P5-4: Problem 5-4
<!--##############################################-->

## P5-4: Problem 5-4A

### P5-4A (1)
Erzeugen Sie eine Haeufigkeitstabelle der Logistikdienstleister im vorliegenden Datensatz von Bestellungen. Dies ist noch keine Visualisierung. Sie sollen lediglich sehen, mit welchen Daten Sie in etwa arbeiten.
```{r, echo=FALSE}
# Antwort (bitte "NULL" ersetzen und vollstaendige verschachtelte Funktion formulieren):
table(electronics$LSP)
```

### P5-4A (2)
Die Haufigkeitstabelle laesst erkennen, dass ein Logistikdienstleister (LSP) einige Male falsch benannt wurde. Der `sub()` Befehl ermoeglicht es Zeichenketten zu tauschen, z.B. falsche LSP-Bezeichnungen. Ersetzen Sie die falschen Eintraege in der LSP-Spalte.  
```{r, echo=FALSE}
# Antwort (bitte "NULL" ersetzen und vollstaendige verschachtelte Funktion formulieren):
electronics$LSP = sub("AJL", "AHL", electronics$LSP, fixed = TRUE)

# Erzeugen Sie eine weitere Haufigkeitstabelle, um zu pruefen, ob Ihre Loesung funktioniert hat.
# Antwort (bitte "NULL" ersetzen und vollstaendige verschachtelte Funktion formulieren):
table(electronics$LSP)
```

## P5-4: Problem 5-4B
### P5-4B (1)
Erzeugen Sie eine Haeufigkeitstabelle der Standorte im vorliegenden Datensatz von Bestellungen. Gibt es Besonderheiten?
```{r, echo=FALSE}
# Antwort (bitte "NULL" ersetzen und vollstaendige verschachtelte Funktion formulieren):
table(electronics$Location)

```

### P5-4B (2)
Es scheinen Eintraege zu fehlen. Lassen Sie sich in der Console das Subset der Bestellungen von electronics anzeigen, welches keine Eintraege bei "Location" hat.
```{r, echo=FALSE}
# Antwort (bitte "NULL" ersetzen und vollstaendige verschachtelte Funktion formulieren):
subset(electronics, Location == "")
```

### P5-4B (3)
Am CustomerName ist (gluecklicherweise) ein einheitliches Land erkennbar. Ersetzen Sie daher alle fehlenden Werte durch das entsprechende Land. Dafuer muessen Sie einen verschachtelten Befehl erzeugen:   
* Sie moechten eine Zuweisung zu einem Data Frame vornehmen, d.h. `DataFrame$Spalte = Wert`
* Von dem Data Frame moechten Sie allerdings nur bestimmte Reihen und Spalten ansprechen, d.h.  `DafaFrame[Reihen,Spalten]$Spalte = Wert` 

```{r}
# Daten ueberschreiben
# Antwort (bitte "NULL" ersetzen und vollstaendige verschachtelte Funktion formulieren):
electronics[electronics$Location == "" ,]$Location = "UK"

# Erzeugen Sie eine weitere Haufigkeitstabelle, um zu pruefen, ob Ihre Loesung funktioniert hat.
# Antwort (bitte "NULL" ersetzen und vollstaendige verschachtelte Funktion formulieren):
table(electronics$Location)
```


## P5-4: Problem 5-4C

### P5-4C (1)
Erzeugen Sie eine Heatmap mit OrderNo fuer x, Location fuer y und Fuellung entsprechend der IFR, Nutzen Sie eine gruen-rot-Skala. Lassen Sie den Plot direkt anzeigen und speichern Sie ihn nicht in einer Variable.  
```{r, echo=FALSE}
# Antwort (bitte "NULL" ersetzen und vollstaendige verschachtelte Funktion formulieren):
ggplot(electronics, 
       aes(x = OrderNo, y = Location, fill = IFR)) + 
  geom_raster() +
  scale_fill_gradient(low = "red", high = "green")


```

### P5-4C (2)
Leider koennen Sie bei der automatisch erstellten Heatmap wenig erkennen. Sie koennen insbesondere  erkennen, dass die Skala automatisch bis 100 geht. Es scheinen also IFR-Werte zu existieren, die weitaus groesser als 1 sind. Dies wuerde bedeuten, dass 100x die bestellte Menge geliefert wurde. Da das ziemlich unrealistisch ist, scheint ein Fehler in den Daten vorzuliegen. Lassen Sie sich ein subset von allen Bestellungen mit IFR >= 2 auf der Console ausgeben.  

**Hinweis:** Lassen Sie sich nur den Tabellenkopf anzeigen!

```{r, echo=FALSE}
# Antwort (bitte "NULL" ersetzen und vollstaendige verschachtelte Funktion formulieren):
head(subset(electronics, IFR >= 2))
```

### P5-4C (3)
Hier liegen anscheinend Fehler vor! Bereinigen Sie fuer diese Bestellungen die Einträge für die Spalte 'ItemsReceived'.  

```{r, echo=FALSE}
# Antwort (bitte "NULL" ersetzen und vollstaendige verschachtelte Funktion formulieren):
electronics[electronics$IFR >= 2 ,]$ItemsReceived = electronics[electronics$IFR >= 2 ,]$ItemsOrdered

#Wiederholen Sie den Befehl aus (2), um zu pruefen, ob Ihre Loesung funktioniert hat. 
# ItemsOrdered sollte ItemsReceived entsprechen. Die IFR muesste weiterhin fehlerhaft sein.
# Antwort (bitte "NULL" ersetzen und vollstaendige verschachtelte Funktion formulieren):
head(subset(electronics, IFR >= 2))
```

### P5-4C (4)
Um die Wirkung Ihrer Aenderungen zu bewerten, muessen Sie die IFR fuer alle Bestellungen neu berechnen.
```{r, echo=FALSE}
# Antwort (NA ersetzen):
electronics$IFR = electronics$ItemsReceived / electronics$ItemsOrdered

#Wiederholen Sie den Befehl aus (2), um zu pruefen, ob Ihre Loesung funktioniert hat. 
# Es duerfte kein Datensatz angezeigt werden.
# Antwort (bitte "NULL" ersetzen und vollstaendige verschachtelte Funktion formulieren):
head(subset(electronics, IFR >= 2))
```

### P5-4C (5)
Plot entsprechend P5-4c (1) erzeugen.  
```{r, echo=FALSE}
# Antwort (bitte "NULL" ersetzen und vollstaendige verschachtelte Funktion formulieren):
ggplot(electronics, 
       aes(x = OrderNo, y = Location, fill = IFR)) + 
  geom_raster() +
  scale_fill_gradient(low = "red", high = "green")


```

### P5-4C (6)
Die automatische Skala der Heatmap beginnt mit 0. Eine Fill rate von 0 wuerde den Versand eines leeren Pakets bedeutet. Dies ist auszuschliessen. Lassen Sie sich ein subset von allen Bestellungen mit IFR == 0 auf der Console ausgeben.

**Hinweis:** Lassen Sie sich nur den Tabellenkopf anzeigen!
```{r, echo=FALSE}
# Antwort (bitte "NULL" ersetzen und vollstaendige verschachtelte Funktion formulieren):
head(subset(electronics, IFR == 0) )
```

### P5-4C (7)
Erstezen Sie die Bestellungen mit IFR == 0 wie in Schritt P5-4c (3)
```{r, echo=FALSE}
# Antwort (bitte "NULL" ersetzen und vollstaendige verschachtelte Funktion formulieren):
electronics[electronics$IFR == 0 ,]$ItemsReceived = electronics[electronics$IFR == 0,]$ItemsOrdered

#Wiederholen Sie den Befehl aus (6), um zu pruefen, ob Ihre Loesung funktioniert hat. ItemsOrdered sollte ItemsReceived entsprechen. Die IFR muesste weiterhin fehlerhaft sein.
# Antwort (bitte "NULL" ersetzen und vollstaendige verschachtelte Funktion formulieren):
head(subset(electronics, IFR == 0))
```

### P5-4C (8)
Um die Wirkung ihrer Aendeurngen zu bewerten, muessen Sie die IFR fuer alle Bestellungen neu berechnen.
```{r, echo=FALSE}
# Antwort (NA ersetzen):
electronics$IFR = electronics$ItemsReceived / electronics$ItemsOrdered

#Wiederholen Sie den Befehl aus (6), um zu pruefen, ob Ihre Loesung funktioniert hat. Es duerfte kein Datensatz angezeigt werden.
# Antwort (bitte "NULL" ersetzen und vollstaendige verschachtelte Funktion formulieren):
head(subset(electronics, IFR == 0))
```

### P5-4C (9)
Ermitteln Sie die durchschnittliche IFR ueber alle Bestellungen neu und geben diese auf der Console aus.
```{r, echo=FALSE}
# Antwort (bitte "NULL" ersetzen und vollstaendige verschachtelte Funktion formulieren):
mean(electronics$IFR)
```



## P5-4: Problem 5-4D

### P5-4D (1)
Erzeugen Sie eine neue Spalte des Data Frame `electronics` mit dem Namen ServiceContract. Verbinden Sie dafuer die Zeichenketten LSP und ServiceLevel. Nutzen Sie dafuer den `paste` Befehl. (`paste(DF$Spalte1, DF$Spalte2)`)
```{r, echo=FALSE}
# Antwort (NA ersetzen):
electronics$ServiceContract = paste(electronics$LSP, electronics$ServiceLevel)

#Lassen Sie sich zur Pruefung der Loesung den Tabellenkopf von electronics anzeigen. (Die neue Spalte muesste die letzte sein.)
head(electronics)
```


### P5-4D (2)
Erzeugen Sie ein Boxplot des Data Frame `electronics` mit ServiceContract als x und TimeTransit als y.  
```{r, echo=FALSE}
# Antwort (bitte "NULL" ersetzen und vollstaendige verschachtelte Funktion formulieren):
ggplot(electronics, 
       aes(x = ServiceContract, y = TimeTransit)) + 
  geom_boxplot()

```

## P5-4: Problem 5-4E

### P5-4E (1)
Erzeugen Sie ein Histogram von ServiceContract (es ist kein y bei den aes anzugeben). Passen Sie Fuellung und Linienfarbe an Wunschfarben an.
```{r, echo=FALSE}
# Antwort (bitte "NULL" ersetzen und vollstaendige verschachtelte Funktion formulieren):
ggplot(electronics, 
       aes(x = TimeTransit)) + 
  geom_histogram(colour = "darkred", fill = "linen")

```


## P5-4: Problem 5-4F

### P5-4F (1)
Durch 5-4D koennen Sie einen LSP als auffaellig einschaetzen. Erstellen Sie von diesem eine Punktwolke. Nutzen Sie ein subset als verschachtelte Funktion innerhalb der ggplot Funktion, um ein Subset von electronics bei den Inputdaten `data =` zu verwenden. Nutzen Sie ausserdem OrderNo als x und TimeTransit als y.   

```{r, echo=FALSE}
# Antwort (bitte "data = electronic" ersetzen entsprechend Aufgabenstellung):
ggplot(data = subset(electronics, LSP == "AHL"), 
       aes(x = OrderNo, y = TimeTransit)) + 
  geom_point()
```


### P5-4F (2)
Ein spezieller Bereich der OrderNo ist auffaellig. Schraenken Sie den Bereich schrittweise ein, indem Sie sich durch Limitierung der Werte der X-Achse den Bereich genauer bestimmen. Die Nutzung der Hilfe kann hier recht lang dauern. Versuchen Sie eine Internetsuchmaschine zu nutzen, um die Loesung zu erhalten!   
```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Antwort (NULL ersetzen und anpassung von P5-4F (1) uebernehmen):
ggplot(subset(electronics, LSP == "AHL"), 
       aes(x = OrderNo, y = TimeTransit)) + 
  xlim(4330500, 4330675) + 
  geom_point()
```


### P5-4F (3)
Lassen Sie sich den Tabellenkopf des Subsets der auffaelligen Bestellungen auf der Console ausgeben. Der Bereich laesst sich folgendermassen zusammenfassen:  

* OrderNo > 4330525, OrderNo < 4330600
* TimeTransit > 50
* LSP == AHL.
```{r}
# Anzeige
head(subset(electronics, LSP == "AHL" & OrderNo > 4330525 & OrderNo < 4330600 & TimeTransit > 50))
```

### P5-4F (4)
Speichern Sie sicherheitshalber die Ausreisser in einer neuen Variable `outliers`. Erstellen Sie eine Zuweisung, in der dieser Variable das subset aus Schritt (3) zugewiesen wird
```{r, echo=FALSE}
# Antwort (NA ersetzen):
outliers = subset(electronics, LSP == "AHL" & OrderNo > 4330525 & OrderNo < 4330600 & TimeTransit > 50)

# Lassen Sie sich den Tabellenkopf von outliers anzeigen
head(outliers)
```


### P5-4F (5)
Bereinigen Sie das Data Frame von Ausreissern indem Sie ein Zuweisung wie folgt erstellen:  

* `Variable = Ausreisserbereinigtes Subset`
* Die Variable ist das Data Frame `electronics`
* Das zugewiesene subset ist das **Gegenteil** von `outliers`, daher `subset(electronics, !(alle Bedingungen))`, denn ! sucht alle Zeilen, die **nicht** die Bedingung erfuellen
*  `alle Bedingungen` entspricht allen Bedingungen, die Sie in Schritt (3) und (4) verwendet haben
*  beachten Sie unbedingt das `!` vor den Konditionen  
```{r, echo=FALSE}
# Antwort (NA ersetzen):
electronics = subset(electronics, !(LSP == "AHL" & OrderNo > 4330525 & OrderNo < 4330600 & TimeTransit > 50))

# Lassen Sie sich zur Ueberpruefung erneut den Plot entsprechend (1) anzeigen. Stellen Sie daher die Y-Achse auf 0 bis 200 ein. Dies benoetigt die (angepasste) Erweiterung von (2).
# Antwort (bitte "NULL" ersetzen und vollstaendige verschachtelte Funktion formulieren):
ggplot(data = subset(electronics, LSP == "AHL"), 
       aes(x = OrderNo, y = TimeTransit)) + 
  geom_point()
```

> **ENDE**