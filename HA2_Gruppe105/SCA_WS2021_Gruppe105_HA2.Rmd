---
title: "SCA_WS2021_Gruppe105_HA1"
output:
  word_document: default
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#Setup environment
library(tidyverse)

#install.packages("data.table")
library(data.table)

library("zoo")
library("forecast")
## Kommentar von Anny
```

## R Markdown

Hausaufgabe 2
```{r}

#Setup environment for HA2
cost = read.csv2("output_cost_8Players_v0010.csv")
prices = read.csv2("output_prices_8Players_v0010.csv")
services = read.csv2("output_services_8Players_v0010.csv")
transactions = read.csv2("output_transactions_8Players_v0010.csv")


```

1) Aggregieren Sie die Verkaufszahlen so, dass Sie eine Tabelle mit der Nachfrage je Monat je Region bekommen
(fuer alle Produkte zusammen einschliesslich Lost Sales! Sie brauchen diese Daten, um die Nachfrage in einer
Region abzuschaetzen). Bereinigen Sie die Daten anschliessend von unnuetzen Daten. Die Daten sollten in
einer neuen Variable mit dem Namen “Demand” gespeichert werden. Die Spalte, welche im DF transactions
noch “Sales” heisst, soll im neuen DF Demand “Demand” heissen. Geben Sie nur den Tabellenkopf aus. Bewertungsrelevant:
Code, Output.
```{r}
#Variable Periode erzeugen.YYYY/MM
transactions$Periode = "YYYY/MM"
#Füge 0 hinzu falls Monat kleiner 10 ist. 
transactions[transactions$Month < 10,]$Periode = paste (transactions[transactions$Month < 10,]$Year, transactions[transactions$Month < 10,]$Month, sep = "/0") 
#Bei Monat größer gleich 10 muss keine 0 hinzugefügt werden.
transactions[transactions$Month >= 10,]$Periode = paste (transactions[transactions$Month >= 10,]$Year, transactions[transactions$Month >= 10,]$Month, sep = "/")

#Datenbereinigung: Transaktionen mit Sales < 0 interessieren uns nicht. Zusätzlich enternen wir Duplikate. Viele Transaktionen kommen doppelt vor, vorallem Lost Sales ist auffällig.
transactions = transactions[transactions$Sales > 0,] %>% unique(.)

#Tabelle mit der Nachfrage je Monat je Region: Aggregieren Sales auf Region und Periode für Gruppe105 und Lost Sales
demand <- transactions %>% aggregate(Sales~region+Periode, data=., sum) 
#Umbenennen von Sales zu Demand. region zu Region umbenennen.
colnames(demand)[3] <- "Demand"
colnames(demand)[1] <- "Region"
#Tabellenkopf ausgeben
demand %>% head()

```

2) Wandeln Sie die aggregierten Demand‐Daten vom Long‐Format in das Wide‐Format um. (Fuer den vorliegenden
Fall gibt es im Long‐Format drei Spalten: Periode, Region und Demand. Im Wide‐Format gibt es im vorliegenden
Fall sechs Spalten: Periode, Demand in Japan, Demand in Peking, Demand in Phlppn, Demand in
Shangh, und Demand in Skorea.) Nutzen Sie dazu die Reshape()‐Funktion. Infos unter diesem Link (<– bitte
anklicken). Geben Sie nur den Tabellenkopf aus. Bewertungsrelevant: Code, Output.
```{r}
demand = reshape(demand, timevar = "Region", idvar = "Periode", direction="wide")
colnames(demand) = c("Periode", "Demand in Japan", "Demand in Peking", "Demand in Phlppn", "Demand in Shangh", "Demand in Skorea")
head(demand)
```

3) Wandeln Sie die aggregierten Verkaufszahlen in den Datentyp time‐series mit Frequenz = 12 um. Jede Demand‐
Spalte (jeder Vektor) soll dabei in eine Time Series umgewandelt werden. Dafuer benoetigt es nur 5 Befehle.
Fuer diese Aufgabe brauchen Sie nichts ausgeben. Bewertungsrelevant: Code.
```{r}
demand_ts_japan = ts(demand$`Demand in Japan`, frequency = 12)
demand_ts_peking = ts(demand$`Demand in Peking`, frequency = 12)
demand_ts_phlppn = ts(demand$`Demand in Phlppn`, frequency = 12)
demand_ts_shangh = ts(demand$`Demand in Shangh`, frequency = 12)
demand_ts_skorea = ts(demand$`Demand in Skorea`, frequency = 12)
```


4) Fuer die exemplarische Region, visualisieren Sie den Nachfrageverlauf sinnvoll. Begruenden Sie Ihre Wahl der
Visualisierung. Achten Sie auf uebersichtliche Achsenbeschriftungen. Bewertungsrelevant: Output, Begruendung.
Hinweis: Wenn Sie ggplot verwenden, kann es notwendig sein, dass Sie bei den aesthetics zusaetzlich
group = 1 angeben muessen, damit Sie einen Plot sehen. Eventuelle Fehlermeldungen sind nicht bewertungsrelevant.
```{r}
#Examplarische Region ist Shangh.
demand_shangh = c("Periode", "Demand in Shangh") %>% demand[.]

#Liniendiagramm für die gesamte Zeitspanne.
ggplot(demand_shangh, aes(x = Periode, y = `Demand in Shangh`, group=1)) + 
  geom_line() +
  # Beschriftung von x-Achse 90 Grad umgedreht
  theme(axis.text.x = element_text(angle=90, vjust = 0.5)) + 
  xlab("Periode YYYY/MM") + 
  ylim(14000, 21500)

#Liniendiagramme für jedes Jahr zur genaueren Betrachtung.
ggplot(demand_shangh[demand_shangh$Periode %like% "2016",], aes(x = Periode, y = `Demand in Shangh`, group=1)) + 
  geom_line() +
  theme(axis.text.x = element_text(angle=45, vjust = 0.5)) + 
  xlab("Periode YYYY/MM") + 
  ylim(14000, 21500)

ggplot(demand_shangh[demand_shangh$Periode %like% "2017",], aes(x = Periode, y = `Demand in Shangh`, group=1)) + 
  geom_line() +
  theme(axis.text.x = element_text(angle=45, vjust = 0.5)) + 
  xlab("Periode YYYY/MM") + 
  ylim(14000, 21500)

ggplot(demand_shangh[demand_shangh$Periode %like% "2018",], aes(x = Periode, y = `Demand in Shangh`, group=1)) + 
  geom_line() +
  theme(axis.text.x = element_text(angle=45, vjust = 0.5)) + 
  xlab("Periode YYYY/MM") + 
  ylim(14000, 21500)

ggplot(demand_shangh[demand_shangh$Periode %like% "2019",], aes(x = Periode, y = `Demand in Shangh`, group=1)) + 
  geom_line() +
  theme(axis.text.x = element_text(angle=45, vjust = 0.5)) + 
  xlab("Periode YYYY/MM") + 
  ylim(14000, 21500)

ggplot(demand_shangh[demand_shangh$Periode %like% "2020",], aes(x = Periode, y = `Demand in Shangh`, group=1)) + 
  geom_line() +
  theme(axis.text.x = element_text(angle=45, vjust = 0.5)) + 
  xlab("Periode YYYY/MM") + 
  ylim(14000, 21500)

#TODO X Achse in Quartale aufteilen.

#Begründung: Unberechenbare Nachfrage. 

```

5) Betrachten Sie die Visualisierung und nehmen Sie zu moeglichen Trends und Saisonalitaeten fuer die exemplarische
Region Stellung. Erachten Sie eine Zeitreihenanalyse in diese Fall als sinnvolle Methode, um den
Nachfrageverlauf zu modellieren? Angenommen, dies ist der Fall: Welche Annahme muessen sie dann treffen,
um die Ergebnisse der Modellierung fuer Ihr Produkt nutzen zu koennen? Bewertungsrelevant: Kommentar.
```{r}
"Die Nachfrage ist jedes Jahr am anfang sehr hoch und sinkt dann erstmal ab. Eine besonders schlechte Nachfrage haben immer in Juli. Im Oktober zieht die Nachrage wieder an um dann wieder im Dezember stark zu sinken. Dieses Verhalten kann als Muster betrachtet werden. Daher macht eine Zeitreihenanalyse Sinn."

#TODO Bullwhip Effekt?
```

6) Nutzen Sie nun Ihre exemplarische Region weiter. Fuehren Sie mit Hilfe der ets()‐Funktion eine Zeitreihenanalyse
durch. Erstellen Sie ein Modell, indem Sie die automatische Festlegung der Modellparameter nutzen (model
= “ZZZ”). Geben Sie (1) eine Zusammenfassung des Modells, (2) die urspruengliche Zeitreihe und (3) die Werte
der Residuen aus. Bewertungsrelevant: Code, Output.
```{r}
ets_shangh = ets(demand_ts_shangh, model = "ZZZ")

cat("\n Zusammenfassung des Modells: \n")
summary(ets_shangh) 

cat("\n Ursprüngliche Zeitreihe: \n")
ets_shangh$x

cat("\n Residiuen: \n")
ets_shangh$residuals
```

7) Wie weit weichen die Modellwerte durchschnittlich von den Originalwerten ab? Interpretieren Sie das Ergebnis
im Hinblick auf die Nutzung des Modells in einem beispielhaften Unternehmensprozess. Bewertungsrelevant:
Output, Kommentar.
```{r}
#Durchschnittliche Abweichung berechnen.
(ets_shangh$x - ets_shangh$fitted) %>% as.numeric() %>% mean()
"Kommentar: Die Modellwerte weichen im durchschnitt um ca. 2.66 Einheiten von den Originalwerten ab. Wen diese Modell beim bestimmen der Bestellmenge verwendet wird, werden vorraussichtlich ca. 3 Einheiten zu wenig bestellt. Dabei sollte berücksichtigt werden, das dies ein Durchschnitt ist, was bedeutet, das mal zu viel, mal zu wenig bestellt wird."
```

8) Erstellen Sie eine Nachfragevorhersage fuer ein weiteres Jahr. 
Visualisieren Sie den Nachfrageverlauf sowie den Verlauf Ihres Prognosemodells 
in einem einzigen ggplot. Begruenden Sie die Wahl der Visualisierung. 
Bewertungsrelevant: Code, Output, Begruendung.
```{r}
# Forecast der Variable fcast_Shangh (forecast fuer exponentielle Glaettung) uebergeben
fcast_Shangh = forecast(m_Shangh, 12)

# forecast ausgeben (anzeigen)
fcast_Shangh
```

*Alternative 2*
*Schritt 1 - DataFrame Original Nr. 1 erstellen*
```{r}
# DataFrame erstellen
  df_Shangh_orig = data.frame(
    period = seq(1, length(fcast_Shangh$x), 1), 
    value = as.numeric(fcast_Shangh$x), 
    grp = rep("original", length(fcast_Shangh$x)))
  
  # Anzeigen des DataFrame 
  df_Shangh_orig
```
*Schritt 2 - DataFrame Vorhersage Nr. 2 erstellen*
(1) `Perioden`-Variable von 1 bis Laenge des Zeitreihe, einer 
(2) `Value`-Variable mit den Werten der Zeitreihe des Forecasts sowie einer 
(3) `grp`-Variable mit festem Wert *fcast*, welche fuer die Gruppierung genutzt wird.
```{r}
# DataFrame erstellen
df_Shangh_fcast = data.frame(
  period = seq(1, length(fcast_Shangh$fitted) + length(fcast_Shangh$mean), 1), 
  value = c(as.numeric(fcast_Shangh$fitted), as.numeric(fcast_Shangh$mean)), 
  grp = rep("fcast", length(fcast_Shangh$fitted) + length(fcast_Shangh$mean)))

# Anzeigen des DataFrame (nur Kopf)
df_Shangh_fcast
```

*Schritt 3 - Verbinden der DataFrames Nr. 1 und Nr. 2*
```{r}
# Verbinden der Data Frames
df_EG = rbind(df_Shangh_orig, df_Shangh_fcast)

# Anzeigen des DataFrame (ausgewaehlte Beobachtungen)
df_EG
```
*Schritt 4 - Visualisierung*
```{r}
# Beachte: der ggplot() Befehl ist deutlich kuerzer aufgrund der vorherigen Integration der Daten in ein 
# Data Frame
ggplot(data = df_EG, aes(x = period, 
                         y = value, ymin = 0, ymax = 110000, colour = grp)) + 
  geom_line()
```


*Alternative 1*
```{r}
# Forecast der Variable fcast_Shangh (forecast fuer exponentielle Glaettung) uebergeben
fcast_Shangh = forecast(m_Shangh, 24)

# forecast ausgeben (anzeigen)
fcast_Shangh


# Hintergrund erzeugen (ohne Daten!)
ggplot(data = NULL, aes(ymin = 0, ymax = 110000)) + 
  
  # Erste Linie Vorhersage (keine Daten; 
  # X-Achse = Reihe von 1 bis laenge fitting Werten und Forecast Werten)
  geom_line(data = NULL,  aes(
    x = seq(1, length(c(fcast_Shangh$fitted, fcast_Shangh$mean)), 1), 
                            
    #Y-Achse = Kombination von fitting Werten und Forecast Werten
    y = c(as.numeric(fcast_Shangh$fitted), as.numeric(fcast_Shangh$mean)),        
      # Beschriftung fuer Farbe festlegen
       colour = 'forecast'))  +                          
  
  # Zweite Linie Ursprung-Zeitreihe 
  # (Keine Daten; X-Achse = Reihe von 1 bis laenge Beobachtungen)
  # Y-Achse = Beobachtungen
  # Beschriftung fuer Farbe festlegen
  geom_line(data = NULL, aes(x = seq(1, length(fcast_Shangh$x), 1), 
                             y = as.numeric(fcast_Shangh$x),                    
                             colour = 'original')) +                            
  
  # Farben fuer Beschriftungen festlegen
  scale_colour_manual(breaks = c("forecast", "original"), values = c("red", "blue"))
```

9) Bewerten Sie Ihr Modell aus Aufgabe 6 mit Hilfe von 4 verschiedenen Fehler‐Kennzahlen, die Sie aus der Uebung
kennen. Welche der Fehler‐Kennzahlen halten Sie fuer geeignet, um die Guete des Modells zu bewerten?
Bewertungsrelevant: Output, Kommentar.
```{r}
# MFE
(ets_shangh$x - ets_shangh$fitted) %>% as.numeric(.) %>% mean(.)
# MAE
(ets_shangh$x - ets_shangh$fitted) %>% as.numeric(.) %>% abs(.)  %>% mean(.)
# MSE
(ets_shangh$x - ets_shangh$fitted)^2 %>% as.numeric(.) %>% mean(.)
# MAPE
(((ets_shangh$x - ets_shangh$fitted)/ as.numeric(ets_shangh$x)) * 100) %>% as.numeric(.) %>% abs(.)  %>% mean(.)
```

10) Vergleichen Sie Ihr Modell insgesamt mit Ihren Vermutungen aus Aufgabe 5. Was stellen Sie fest? Bewertungsrelevant:
Kommentar.
```{r}

```

11) Erstellen Sie fuer die uebrigen Regionen ebenso Modelle zur Nachfragevorhersage (d.h. 4 weitere Modelle).
Nutzen Sie erneut die automatische Festlegung der Modellparameter (model = "ZZZ"). Berechnen Sie zudem
fuer jedes Modell den MAPE, um den Vergleich der Modelle zu ermoeglichen. Nehmen Sie dazu Stellung,
welches Modell laut der bewertenden Information das “beste” der vier Modelle sei. Bewertungsrelevant: Output,
Kommentar.
```{r}
#Modelle für die übrigen Regionne erstellen.
ets_japan = ets(demand_ts_japan, model = "ZZZ")
ets_peking = ets(demand_ts_peking, model = "ZZZ")
ets_phlppn = ets(demand_ts_phlppn, model = "ZZZ")
ets_skorea = ets(demand_ts_skorea, model = "ZZZ")

#Funktion um MAPE zu berechnen
mape <- function(actual,pred){
           mape <- mean(abs((actual - pred)/actual))*100
           return (mape)
}

#MAPE ausgeben
cat("Modell für Japan hat einen Wert für MAPE von", mape(demand_ts_japan, ets_japan$fitted),".\n")
cat("Modell für Peking hat einen Wert für MAPE von", mape(demand_ts_peking, ets_peking$fitted),".\n")
cat("Modell für Phillipin hat einen Wert für MAPE von", mape(demand_ts_phlppn, ets_phlppn$fitted),".\n")
cat("Modell für Südkorea hat einen Wert für MAPE von", mape(demand_ts_skorea, ets_skorea$fitted),".\n")



```

12) Ihre Chefin kommt bei einer Firmenfeier auf Sie zu und schlaegt Ihnen eine Wette vor. Sie sagt: “Ich wette mit
Ihnen um 100 Euro, dass die Nachfrage nach Limonade in Peking, den Philippinen und Suedkorea im naechsten
Monat (Januar 2021) in Summe 45.000 Flaschen nicht uebersteigen wird.” Sollten Sie diese Wette eingehen?
Bewertungsrelevant: Output, Kommentar.
```{r}
#Summe von Sales für Peking, Philippinen und Südkorea.
transactions[transactions$Periode %like% "/01" & transactions$region!="Shangh",]$Sales %>% sum()


```

13) Ihr guter Freund Olaf wohnt in Shanghai und besitzt dort drei der Supermaerkte, die Ihre Limonaden‐Marke
fuehren. Er wuerde gern wissen, wie viel Limonade er im ersten Quartal von 2021 wahrscheinlich bestellen
muss. Helfen Sie Olaf. Bewertungsrelevant: Output, Kommentar.
```{r}

```