---
title: "SCA_WS2021_Gruppe105_HA1"
output:
  word_document: default
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#Setup environment
library(tidyverse)

#install.packages("data.table")
library(data.table)

library("zoo")
library("forecast")
```

## R Markdown

Hausaufgabe 2
```{r}

#Setup environment for HA2
cost = read.csv2("output_cost_8Players_v0010.csv")
prices = read.csv2("output_prices_8Players_v0010.csv")
services = read.csv2("output_services_8Players_v0010.csv")
transactions = read.csv2("output_transactions_8Players_v0010.csv")
```

1) Aggregieren Sie die Verkaufszahlen so, dass Sie eine Tabelle mit der Nachfrage je Monat je Region bekommen
(fuer alle Produkte zusammen einschliesslich Lost Sales! Sie brauchen diese Daten, um die Nachfrage in einer
Region abzuschaetzen). Bereinigen Sie die Daten anschliessend von unnuetzen Daten. Die Daten sollten in
einer neuen Variable mit dem Namen “Demand” gespeichert werden. Die Spalte, welche im DF transactions
noch “Sales” heisst, soll im neuen DF Demand “Demand” heissen. Geben Sie nur den Tabellenkopf aus. Bewertungsrelevant:
Code, Output.
```{r}
#Variable Periode erzeugen.YYYY/MM
transactions$Periode = "YYYY/MM"

#Füge 0 hinzu falls Monat kleiner 10 ist. 
transactions[transactions$Month < 10,]$Periode = paste (transactions[transactions$Month < 10,]$Year, transactions[transactions$Month < 10,]$Month, sep = "/0") 

#Bei Monat größer gleich 10 muss keine 0 hinzugefügt werden.
transactions[transactions$Month >= 10,]$Periode = paste (transactions[transactions$Month >= 10,]$Year, transactions[transactions$Month >= 10,]$Month, sep = "/")

#Datenbereinigung: Transaktionen mit Sales < 0 interessieren uns nicht. Zusätzlich enternen wir Duplikate. Viele Transaktionen kommen doppelt vor, vorallem Lost Sales ist auffällig.
transactions = transactions[transactions$Sales > 0,] %>% unique(.)

#Tabelle mit der Nachfrage je Monat je Region: Aggregieren Sales auf Region und Periode für Gruppe105 und Lost Sales
demand <- transactions %>% aggregate(Sales~region+Periode, data=., sum) 

#Umbenennen von Sales zu Demand. region zu Region umbenennen.
colnames(demand)[3] <- "Demand"
colnames(demand)[1] <- "Region"

#Tabellenkopf ausgeben
demand %>% head()

```

2) Wandeln Sie die aggregierten Demand‐Daten vom Long‐Format in das Wide‐Format um. (Fuer den vorliegenden
Fall gibt es im Long‐Format drei Spalten: Periode, Region und Demand. Im Wide‐Format gibt es im vorliegenden
Fall sechs Spalten: Periode, Demand in Japan, Demand in Peking, Demand in Phlppn, Demand in
Shangh, und Demand in Skorea.) Nutzen Sie dazu die Reshape()‐Funktion. Infos unter diesem Link (<– bitte
anklicken). Geben Sie nur den Tabellenkopf aus. Bewertungsrelevant: Code, Output.
```{r}
demand = reshape(demand, timevar = "Region", idvar = "Periode", direction="wide")
colnames(demand) = c("Periode", "Demand in Japan", "Demand in Peking", "Demand in Phlppn", "Demand in Shangh", "Demand in Skorea")
demand
```

3) Wandeln Sie die aggregierten Verkaufszahlen in den Datentyp time‐series mit Frequenz = 12 um. Jede Demand‐
Spalte (jeder Vektor) soll dabei in eine Time Series umgewandelt werden. Dafuer benoetigt es nur 5 Befehle.
Fuer diese Aufgabe brauchen Sie nichts ausgeben. Bewertungsrelevant: Code.
```{r}
demand_ts_japan = ts(demand$`Demand in Japan`, frequency = 12)
demand_ts_peking = ts(demand$`Demand in Peking`, frequency = 12)
demand_ts_phlppn = ts(demand$`Demand in Phlppn`, frequency = 12)
demand_ts_shangh = ts(demand$`Demand in Shangh`, frequency = 12)
demand_ts_skorea = ts(demand$`Demand in Skorea`, frequency = 12)
```



*ZU BEARBEITEN*
4) Fuer die exemplarische Region, visualisieren Sie den Nachfrageverlauf sinnvoll. Begruenden Sie Ihre Wahl der
Visualisierung. Achten Sie auf uebersichtliche Achsenbeschriftungen. Bewertungsrelevant: Output, Begruendung.
Hinweis: Wenn Sie ggplot verwenden, kann es notwendig sein, dass Sie bei den aesthetics zusaetzlich
group = 1 angeben muessen, damit Sie einen Plot sehen. Eventuelle Fehlermeldungen sind nicht bewertungsrelevant.
```{r}
#Examplarische Region ist Shangh.
demand_shangh = c("Periode", "Demand in Shangh") %>% demand[.]

#Liniendiagramm für die gesamte Zeitspanne.
ggplot(demand_shangh, aes(x = Periode, y = `Demand in Shangh`, group=1)) + 
  geom_line() +
  # Beschriftung von x-Achse 90 Grad umgedreht
  theme(axis.text.x = element_text(angle=90, vjust = 0.5)) + 
  xlab("Periode YYYY/MM")

#Liniendiagramme für jedes Jahr zur genaueren Betrachtung.
ggplot(demand_shangh[demand_shangh$Periode %like% "2016",], aes(x = Periode, y = `Demand in Shangh`, group=1)) + 
  geom_line() +
  theme(axis.text.x = element_text(angle=45, vjust = 0.5)) + 
  xlab("Periode YYYY/MM")

ggplot(demand_shangh[demand_shangh$Periode %like% "2017",], aes(x = Periode, y = `Demand in Shangh`, group=1)) + 
  geom_line() +
  theme(axis.text.x = element_text(angle=45, vjust = 0.5)) + 
  xlab("Periode YYYY/MM")

ggplot(demand_shangh[demand_shangh$Periode %like% "2018",], aes(x = Periode, y = `Demand in Shangh`, group=1)) + 
  geom_line() +
  theme(axis.text.x = element_text(angle=45, vjust = 0.5)) + 
  xlab("Periode YYYY/MM")

ggplot(demand_shangh[demand_shangh$Periode %like% "2019",], aes(x = Periode, y = `Demand in Shangh`, group=1)) + 
  geom_line() +
  theme(axis.text.x = element_text(angle=45, vjust = 0.5)) + 
  xlab("Periode YYYY/MM")

ggplot(demand_shangh[demand_shangh$Periode %like% "2020",], aes(x = Periode, y = `Demand in Shangh`, group=1)) + 
  geom_line() +
  theme(axis.text.x = element_text(angle=45, vjust = 0.5)) + 
  xlab("Periode YYYY/MM")

#TODO X Achse in Quartale aufteilen.

#Begründung: Unberechenbare Nachfrage. 

```

5) Betrachten Sie die Visualisierung und nehmen Sie zu moeglichen Trends und Saisonalitaeten fuer die exemplarische
Region Stellung. Erachten Sie eine Zeitreihenanalyse in diese Fall als sinnvolle Methode, um den
Nachfrageverlauf zu modellieren? Angenommen, dies ist der Fall: Welche Annahme muessen sie dann treffen,
um die Ergebnisse der Modellierung fuer Ihr Produkt nutzen zu koennen? Bewertungsrelevant: Kommentar.
```{r}
"Die Nachfrage ist jedes Jahr am anfang sehr hoch und sinkt dann erstmal ab. Eine besonders schlechte Nachfrage haben immer in Juli. Im Oktober zieht die Nachrage wieder an um dann wieder im Dezember stark zu sinken. Dieses Verhalten kann als Muster betrachtet werden. Daher macht eine Zeitreihenanalyse Sinn."

#TODO Bullwhip Effekt?
```

6) Nutzen Sie nun Ihre exemplarische Region weiter. Fuehren Sie mit Hilfe der ets()‐Funktion eine Zeitreihenanalyse
durch. Erstellen Sie ein Modell, indem Sie die automatische Festlegung der Modellparameter nutzen (model
= “ZZZ”). Geben Sie (1) eine Zusammenfassung des Modells, (2) die urspruengliche Zeitreihe und (3) die Werte
der Residuen aus. Bewertungsrelevant: Code, Output.
```{r}
ets_shangh = ets(demand_ts_shangh, model = "ZZZ")

cat("\n Zusammenfassung des Modells: \n")
summary(ets_shangh) 

cat("\n Ursprüngliche Zeitreihe: \n")
ets_shangh$x

cat("\n Residiuen: \n")
ets_shangh$residuals
```

7) Wie weit weichen die Modellwerte durchschnittlich von den Originalwerten ab? Interpretieren Sie das Ergebnis
im Hinblick auf die Nutzung des Modells in einem beispielhaften Unternehmensprozess. Bewertungsrelevant:
Output, Kommentar.
```{r}
#Durchschnittliche Abweichung berechnen.
(ets_shangh$x - ets_shangh$fitted) %>% as.numeric() %>% mean()
"Kommentar: Die Modellwerte weichen im durchschnitt um ca. 2.66 Einheiten von den Originalwerten ab. Wen diese Modell beim bestimmen der Bestellmenge verwendet wird, werden vorraussichtlich ca. 3 Einheiten zu wenig bestellt. Dabei sollte berücksichtigt werden, das dies ein Durchschnitt ist, was bedeutet, das mal zu viel, mal zu wenig bestellt wird."
```



*ZU BEARBEITEN*
*JAHR UND MIONAT AUF DER X-ACHSE FEHLEN*
8) Erstellen Sie eine Nachfragevorhersage fuer ein weiteres Jahr. 
Visualisieren Sie den Nachfrageverlauf sowie den Verlauf Ihres Prognosemodells 
in einem einzigen ggplot. Begruenden Sie die Wahl der Visualisierung. 
Bewertungsrelevant: Code, Output, Begruendung.
```{r}
# Forecast der Variable fcast_Shangh (forecast fuer exponentielle Glaettung) uebergeben
fcast_Shangh = forecast(ets_shangh$x, 12)

# forecast ausgeben (anzeigen)
fcast_Shangh
```

*Alternative 2*
*Schritt 1 - DataFrame Original Nr. 1 erstellen*
```{r}
# DataFrame erstellen
  df_Shangh_orig = data.frame(
    period = seq(1, length(fcast_Shangh$x), 1), 
    value = as.numeric(fcast_Shangh$x), 
    grp = rep("original", length(fcast_Shangh$x)))
  
  # Anzeigen des DataFrame 
  df_Shangh_orig
```
*Schritt 2 - DataFrame Vorhersage Nr. 2 erstellen*
(1) `Perioden`-Variable von 1 bis Laenge des Zeitreihe, einer 
(2) `Value`-Variable mit den Werten der Zeitreihe des Forecasts sowie einer 
(3) `grp`-Variable mit festem Wert *fcast*, welche fuer die Gruppierung genutzt wird.
```{r}
# DataFrame erstellen
df_Shangh_fcast = data.frame(
  period = seq(1, length(fcast_Shangh$fitted) + length(fcast_Shangh$mean), 1), 
  value = c(as.numeric(fcast_Shangh$fitted), as.numeric(fcast_Shangh$mean)), 
  grp = rep("fcast", length(fcast_Shangh$fitted) + length(fcast_Shangh$mean)))

# Anzeigen des DataFrame (nur Kopf)
df_Shangh_fcast
```

*Schritt 3 - Verbinden der DataFrames Nr. 1 und Nr. 2*
```{r}
# Verbinden der Data Frames
df_EG = rbind(df_Shangh_orig, df_Shangh_fcast)

# Anzeigen des DataFrame (ausgewaehlte Beobachtungen)
df_EG
```

*Schritt 4 - Visualisierung*
*WAS FEHLT: MONAT UND JAHRE AUF X-ACHSE*
```{r}
ggplot(data = df_EG, aes(x = period, 
                         y = value, ymin = 12500, ymax = 21500, colour = grp)) + 
  geom_line() +

# Beschriftung von x-Achse 90 Grad umgedreht
  theme(axis.text.x = element_text(angle=90, vjust = 0.5)) + 
  xlab("Periode Jahr/Monat") + 
  ylim(12500, 21500) 
```


*Alternative 1*
*YYYY/MM fehlt!*
```{r}
# Forecast der Variable fcast_Shangh (forecast fuer exponentielle Glaettung) uebergeben
fcast_Shangh = forecast(ets_shangh$x, 24)

# forecast ausgeben (anzeigen)
fcast_Shangh


# Hintergrund erzeugen (ohne Daten!)
ggplot(data = NULL, aes(ymin = 0, ymax = 110000)) + 
  
  # Erste Linie Vorhersage (keine Daten; 
  # X-Achse = Reihe von 1 bis laenge fitting Werten und Forecast Werten)
  geom_line(data = NULL,  aes(
    x = seq(1, length(c(fcast_Shangh$fitted, fcast_Shangh$mean)), 1), 
                            
    #Y-Achse = Kombination von fitting Werten und Forecast Werten
    y = c(as.numeric(fcast_Shangh$fitted), as.numeric(fcast_Shangh$mean)),        
      # Beschriftung fuer Farbe festlegen
       colour = 'forecast'))  +                          
  
  # Zweite Linie Ursprung-Zeitreihe 
  # (Keine Daten; X-Achse = Reihe von 1 bis laenge Beobachtungen)
  # Y-Achse = Beobachtungen
  # Beschriftung fuer Farbe festlegen
  geom_line(data = NULL, aes(x = seq(1, length(fcast_Shangh$x), 1), 
                             y = as.numeric(fcast_Shangh$x),                    
                             colour = 'original')) +                            
  
  # Farben fuer Beschriftungen festlegen
  scale_colour_manual(breaks = c("forecast", "original"), values = c("red", "blue")) +
  
  theme(axis.text.x = element_text(angle=90, vjust = 0.5)) + 
  xlab("Periode Jahr/Monat") + 
  ylim(12500, 21500)
```
Begruendung: Um den Nachfrageverlauf sowie die Vorhersage am ubersichtlichsten
zu visualisieren, haben wir uns fuer einen Liniendiagramm entschieden. 
Die Linie der urspruenglichen Nachfrage haben wir in Kombination mit der
Linie der Vorhersage visualisiert.
Auf der x-Achse haben wir die Perioden 0 bis 36 der urspruenglichen Nachfrage 
sowie der Vorhersage abgebildet. 
Auf der y-Achse findet sich die Anzahl der Nachfrage von 0 bis 110000 wieder.
Hierbei wird der direkte Vergleich am deutlichsten indem die Farbe rot fuer die
Vorhersage steht und blau fur die urspruengliche Nachfrage. Daher ist die 
Verwendung eines Liniendiagramms hier am sinnvollsten.




9) Bewerten Sie Ihr Modell aus Aufgabe 6 mit Hilfe von 4 verschiedenen Fehler‐Kennzahlen, die Sie aus der Uebung
kennen. Welche der Fehler‐Kennzahlen halten Sie fuer geeignet, um die Guete des Modells zu bewerten?
Bewertungsrelevant: Output, Kommentar.
```{r}
# (1) MFE, Mean Forecast Error
MFE <- (ets_shangh$x - ets_shangh$fitted) %>% as.numeric(.) %>% mean(.)

# (2) MAE, Mean absolute Error
MAE <- (ets_shangh$x - ets_shangh$fitted) %>% as.numeric(.) %>% abs(.)  %>% mean(.)

# (3) MSE, Mean squared Error 
MSE <- (ets_shangh$x - ets_shangh$fitted)^2 %>% as.numeric(.) %>% mean(.)

# (4) MAPE, Mean Absolute Percentage Error
MAPE <- (((ets_shangh$x - ets_shangh$fitted)/ as.numeric(ets_shangh$x)) * 100) %>% as.numeric(.) %>% abs(.)  %>% mean(.)

cat("Es liegen folgende vier Fehlerkennzahlen vor. MFE betraegt", MFE,
    ", MAE betreagt", MAE, ", MAE betreagt", MSE,
    " und MAPE betreagt", MAPE)
```
Kommentar zu Aufgabe 9: 
Der Mean Forecast Error (MFE) zeigt durchschnittliche Fehler eines Modells an,
wobei sich positive und negative Fehler sich ausgleichen koennen.

Der Mean absolute Error (MAE) zeigt durchschnittliche absolute Fehler.
Der Ausgleich positiver und negativer Fehler wird verhindert, 
jedoch anhängig von Skalierung der Daten und daher schwer vergleichbar.
Zudem sind alle Fehler gleich gewichtet.

Der Mean squared Error (MSE) zeigt durchschnittliche quadratische Fehler.
Er verhindert den Ausgleich positiver und negativer Fehler, 
jedoch ist es abhaengig von der Skalierung der Daten und daher schwer 
vergleichbar. Größere Fehler werden stärker gewichtet aufgrund des Quadrierens.

Der Mean Absolute Percentage Error (MAPE) zeigt durchschnittliche 
prozentuale Fehler. Er ermöglicht Vergleichbarkeit bei unterschiedlicher 
Skalierung. Zudem werden kleine Abweichungen bei kleinem y stark gewertet.

Wir halten die Fehlerkennzahl MFE und MAPE als geeignete Fehlerkennzahlen.
MFE macht Sinn, da der durchschnittliche Fehler ersichtlich wird. Man
erkennt in der Berechnung, wie sich die Abweichung von der vorigen Periode zur
naechsten Periode verhealt.
MAPE koennte man ebenfalls in Betracht ziehen, da uns die prozentuale Fehler-
zahl bei der Auswertung helfen koennte. Hierbei ist darauf zu achten, dass keine
große Abweichung des y-Wertes bzw. Nachfrage zur vorigen Periode vorliegt. 



10) Vergleichen Sie Ihr Modell insgesamt mit Ihren Vermutungen aus Aufgabe 5. Was stellen Sie fest? Bewertungsrelevant:
Kommentar.

Kommentar zu Aufgabe 10: Beim Vergleich unseres voherigen Modells zu den 
Vermutungen aus Aufgabe 5 koennen wir feststellen, dass sich der Zukunftstrend 
in der Region Shanghai gegenueber dem urspruenglichen Trend sinkender Nachfrage 
bestaetigen laesst.
Zudem gibt es bei der Saisonalitaet zwar ein wiederkehrendes Verhaltensmuster
im urspruenglichen Modell, jedoch hat die Nachfrage im Vorhersage Modell 
geringere Schwankungen als as urspruengliche Modell. 
Die Nachfrage im Vorhersage Modell zeigt uns kaum ein aussagekraeftiges 
wiederkehrendes Verhalten in der Nachfrage, sodass wir annehmen koennen, dass
sich die Nachfrage sich kaum nach einer Periode richtet und  tendenziell immer 
weiter abnimmt.
Allgemein erachten wir die Zeitreihenanalyse hier durchaus als sinnvoll, da wir 
durch die historische Nachfrage als Indikator eine sinkende zukuenftige 
Nachfrage identifiziert haben. Jedoch gilt es immer zu beruecksichtigen,
dass die Vorhersagen immer eine gewissen Ungenauigkeit haben.



11) Erstellen Sie fuer die uebrigen Regionen ebenso Modelle zur Nachfragevorhersage (d.h. 4 weitere Modelle).
Nutzen Sie erneut die automatische Festlegung der Modellparameter (model = "ZZZ"). Berechnen Sie zudem
fuer jedes Modell den MAPE, um den Vergleich der Modelle zu ermoeglichen. Nehmen Sie dazu Stellung,
welches Modell laut der bewertenden Information das “beste” der vier Modelle sei. Bewertungsrelevant: Output,
Kommentar.
```{r}
#Modelle für die übrigen Regionne erstellen.
ets_japan = ets(demand_ts_japan, model = "ZZZ")
ets_peking = ets(demand_ts_peking, model = "ZZZ")
ets_phlppn = ets(demand_ts_phlppn, model = "ZZZ")
ets_skorea = ets(demand_ts_skorea, model = "ZZZ")

#Funktion um MAPE zu berechnen
mape <- function(actual,pred){
           mape <- mean(abs((actual - pred)/actual))*100
           return (mape)
}

#MAPE ausgeben
cat("Modell für Japan hat einen Wert für MAPE von", mape(demand_ts_japan, ets_japan$fitted),".\n")
cat("Modell für Peking hat einen Wert für MAPE von", mape(demand_ts_peking, ets_peking$fitted),".\n")
cat("Modell für Phillipin hat einen Wert für MAPE von", mape(demand_ts_phlppn, ets_phlppn$fitted),".\n")
cat("Modell für Südkorea hat einen Wert für MAPE von", mape(demand_ts_skorea, ets_skorea$fitted),".\n")
```

12) Ihre Chefin kommt bei einer Firmenfeier auf Sie zu und schlaegt Ihnen eine Wette vor. Sie sagt: “Ich wette mit
Ihnen um 100 Euro, dass die Nachfrage nach Limonade in Peking, den Philippinen und Suedkorea im naechsten
Monat (Januar 2021) in Summe 45.000 Flaschen nicht uebersteigen wird.” Sollten Sie diese Wette eingehen?
Bewertungsrelevant: Output, Kommentar.
*SPALTE UMBENENNEN*
```{r}
fcast_Peking = data.frame(forecast(ets_peking, 12))
fcast_Philippinen = data.frame(forecast(ets_phlppn, 12))
fcast_Suedkorea = data.frame(forecast(ets_skorea, 12))

# Dataframe kombinieren und Summe von Sales für Peking, Philippinen und Südkorea
SumRegion <- rbind(fcast_Peking + fcast_Philippinen + fcast_Suedkorea)

# Tabellenkopf erste Zeile bzw. Januar 2021 von forecast ausgeben
head(SumRegion, 1)
```



13) Ihr guter Freund Olaf wohnt in Shanghai und besitzt dort drei der Supermaerkte, die Ihre Limonaden‐Marke
fuehren. Er wuerde gern wissen, wie viel Limonade er im ersten Quartal von 2021 wahrscheinlich bestellen
muss. Helfen Sie Olaf. Bewertungsrelevant: Output, Kommentar.
```{r}
# (1) Datenbereinigen: Nur Produkt Gruppe105 in der Region Shanghai 
DemandShanghai = subset(transactions, Product == "Gruppe105" & 
                                      region=="Shangh" &
                                      Sales > 0)
DemandShanghai <- unique(DemandShanghai)

# (2) Aggregieren
DemandShanghai = aggregate(Sales ~ Periode, data = DemandShanghai, sum)

# (3) Erstellen der Zeitreihe
ts_Shanghai = ts(DemandShanghai$Sales, frequency = 12)

# (4) Modell erstellen
m1_Shanghai = ets(ts_Shanghai, model="ZZZ")

# Die Vorhersage Nachfrage bezieht sich auf 5 Gescheafte. 
fcast1_Shanghai = data.frame(forecast(m1_Shanghai, 12))

# Da Olaf nur 3 Geschaefte hat, muessen wir die Anzahl anpassen und runden
fcast1_Shanghai <- round((fcast1_Shanghai[1]/5)*3,2)

# Spaltenname aendern
colnames(fcast1_Shanghai) = c("Demand Forecast Q1")

# 3 Monate bzw. ein Quartal anzeigen
head(fcast1_Shanghai, 3)[1]

#TODO Periode anpassen
```
Kommentar zu Aufgabe 13: Anhand unseres Vorhersagemodells basierend auf den
Vergangenheitsdaten der Nachfrage in Shanghai empfehlen wir unseren Freund Olaf 
im ersten Quartal in Januar 1681 Limonaden-Flaschen zu kaufen sowie im Februar 
1699 und im Maerz 1510 Limonaden-Flaschen. Hier gilt es insbesondere zu 
beruecksichtigen, dass die alte Vorhersage alle fuenf Geschaefte und ihre Nach-
fragemenge umfasse, daher haben wir die Anzahl der Nachfrage auf die Anzahl
der drei Supermaerkte reduziert, die Olaf besitzt.
